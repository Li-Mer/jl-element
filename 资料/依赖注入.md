User: provide(collapseContextKey, {
activeNames,
handleItemClick,
});

const collapseContext = inject(collapseContextKey);

为什么这里要通过provide和inject这两种形式来传递值呢

GitHub Copilot: 在 Vue 的组件库开发中（特别是像 Collapse、Tabs、RadioGroup 这类组件），使用 `provide` 和 `inject`（依赖注入）是**最标准且最优雅**的解决方案。

主要原因有以下几点：

### 1. 解决 Slot（插槽）无法直接传递 Props 的问题（核心原因）

这是最关键的原因。请观察你的组件在使用时的结构：

```html
<!-- 父组件 -->
<jl-collapse v-model="activeNames">
  <!-- 子组件是通过 slot 嵌入的 -->
  <jl-collapse-item name="1" title="标题1">内容1</jl-collapse-item>
  <jl-collapse-item name="2" title="标题2">内容2</jl-collapse-item>
</jl-collapse>
```

在 Collapse.vue 的模板中，你写的是：

```html
<template>
  <div class="jl-collapse">
    <slot></slot>
    <!-- 子组件在这里渲染 -->
  </div>
</template>
```

**父组件无法直接向 `<slot>` 里的组件传递 Props。**
因为 `jl-collapse-item` 是写在父组件的标签体内部的，而不是在 Collapse.vue 的模板代码里直接调用的。你无法写出 `<CollapseItem :active-names="activeNames" />` 这样的代码，因为父组件根本不知道用户会在插槽里放什么。

`provide/inject` 机制跳过的 DOM 结构的限制，允许父组件向其内部所有后代组件（无论是在模板里写的，还是通过 slot 传入的）“广播”数据。

### 2. 避免“Props Drilling”（层级透传）

虽然通常 `CollapseItem` 是 `Collapse` 的直接子元素，但用户有可能会这样写：

```html
<jl-collapse>
  <div class="wrapper-div">
    <jl-collapse-item name="1">...</jl-collapse-item>
  </div>
</jl-collapse>
```

如果使用 Props，中间的 `div` 会阻断数据的传递。而 `provide` 和 `inject` 可以**跨越层级**。只要 `CollapseItem` 是 `Collapse` 的后代节点，它就能接收到注入的数据，不用关心中间隔了多少层 HTML 标签。

### 3. 维护单一数据源（Single Source of Truth）

`Collapse` 组件维护了整个折叠面板的状态（`activeNames`）和逻辑（`handleItemClick`）。

- **父组件 (Collapse)**: “我是大脑，我知道当前哪一项是展开的，我也知道如何处理点击。”
- **子组件 (CollapseItem)**: “我只是 UI，我需要问大脑我现在是否应该展开（读取 `activeNames`），被点击时我通知大脑（调用 `handleItemClick`）。”

通过 `provide`，父组件将这些**响应式状态**和**操作方法**暴露给所有子组件，确保所有子组件共享同一份状态。如果使用 `emit` / `props` 来回传递，对于复杂的父子嵌套关系来说代码会变得非常难以维护。

### 总结

- **为什么不用 Props？** 因为通过 `<slot>` 渲染的子组件，父组件无法直接通过模板语法给它绑 props。
- **为什么不用 `$parent`？** Vue 3 移除了 `$children`，且过度依赖 `$parent` 会导致高度耦合（子组件必须依附于特定父组件实例）。
- **依赖注入** 是 Vue 官方推荐的用于组件库内部父子组件（Container/Item 模式）通信的最佳实践。
